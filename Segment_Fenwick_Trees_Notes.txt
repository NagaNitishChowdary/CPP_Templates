Segment Trees
-------------

when to use: 
1 ---> To find min/max value in an range [l, r] when given q queries 
Bruteforce ---> q * (r-l+1) ---> q * N [worst case] 

Def: Segment Tree is a data structure which gives the range query in log(time) 
---

		
	ind 

   2*ind+1   2*ind+2




2 ---> Take the size as 4*n (seg[4*n]) ---> It works for all cases

// Building Segment Tree
seq[4*n]

void f(ind, low, high){
    if(low == high){
	seq[low] = arr[low] ; 
	return ; 
    }

    int mid = (low + high)/2 ; 
    f(2*ind+1, low, mid) ; 
    f(2*ind+2, mid+1, high) ; 

    seq[ind] = min(seq[2*mid+1], seq[2*mid+2]) ;
}


// Time Complexity
// O(4*n) ===> logically tc is equal to number of nodes visited 
// At worst case, the nodes are 4*n 



3 ---> Queries 

min(L, R) 

a ---> partial overlap of nodes with range(L, R)

call left node
call right node 
return min(left, right) 
 
b ---> What is there is no overlap with the range(L, R) 

return INT_MAX [for finding min in range]
return INT_MIN [for finding max in range]

c ---> complete overlap with (L, R)

return seg[ind] 


// Time Complexity
(l r) -> small range  [Most of the nodes will be no overlap] ---> O(log n) 
(l r) -> high range [Most of the nodes is complete overlap] ---> O(log n) 
(l r) -> medium range ---> O(2log n   or 3log n   or 4log n) ---> O(log n)  



query(ind, low, high, l, r){
    
    // case 1 ---> no overlap 
    //   [l r] [low high]   (or)  [low high] [l r]

    if(high < l or r < low){
	return INT_MAX ; // (for finding min in range)
	return INT_MIN ; // (for finding max in range) 
    } 

    // case 2 ---> complete overlap
    //   [l low high r] 
    
    if(l <= low && high <= r){
	return seg[ind] ;
    }

    // case 3 ---> partial overlap
    //   [low l high r]  (or)  [l low r high] 

    int mid = (low + high)/2 ; 
    int left = query(2*ind+1, low, mid, l, r) ; 
    int right = query(2*ind+2, mid+1, right, l, r) ; 
    return seg[ind] = min(left, right) ; 

}



Point Update
------------
Usecase:  Given an array arr=[2, 1, 0, 3, 5, 4]
There are 2 types of queries 
Type 1: given me the min in the range (l, r)
Type 2: update the val in the ind (ind, val) 


update(ind, low, high, i, val){
    if(low == high){
	seg[ind] = val ; 
        return ; 
    }

    int mid = (low + high)/2 ; 
    if(i <= mid) {
	update(2*ind+1, low, mid, i, val) 
    } else {
	update(2*ind+2, mid+1, high, i, val) 
    } 

    seg[ind] = min(seg[2*ind+1], seg[2*ind+2]) ; 
}




Example: https://codeforces.com/contest/339/problem/D














Range Updates
-------------
update +val from range l to r 

Time Complexity:  [r-l+1] * log (N) 

This is where lazy propagation comes into play. 


Lazy Propagation on Segment Trees
---------------------------------
---> Update the node when you visit it 
---> Once you update, propagate the update downwards




1 ---> We will create one more node for every node in the segment tree [lazy node] 



How Range updates will be handled ? 

---> Traverse in the segment tree [When you are traversing, update previous remaining updates]
	----> check if the node completely overlaps with (L,R) 
	      ---> Update the node 
              ---> Lazy propagate downwards	
	      ---> return 

        ----> check if the node partially overlaps 
	      ---> call left 
              ---> call right
	      ---> node = left + right  

	----> No overlaps
	      ---> return 


code:
-----

#include<bits/stdc++.h>
using namespace std; 
class ST {
	vector<int> seg, lazy; 
public: 
	ST(int n) {
		seg.resize(4 * n); 
		lazy.resize(4 * n); 
	}
public: 
	void build(int ind, int low, int high, int arr[]) {
		if(low == high) {
			seg[ind] = arr[low];
			return; 
		}
		int mid = (low + high) >> 1; 
		build(2*ind+1, low, mid, arr); 
		build(2*ind+2, mid+1, high, arr); 
		seg[ind] = seg[2*ind+1] + seg[2*ind+2];
	}
public:
	void update(int ind, int low, int high, int l, int r, 
		int val) {
		// update the previous remaining updates 
		// and propogate downwards 
		if(lazy[ind] != 0) {
			seg[ind] += (high - low + 1) * lazy[ind]; 
			// propogate the lazy update downwards
			// for the remaining nodes to get updated 
			if(low != high) {
				lazy[2*ind+1] += lazy[ind]; 
				lazy[2*ind+2] += lazy[ind]; 
			}

			lazy[ind] = 0; 
		}

		// no overlap 
		// we don't do anything and return 
		// low high l r or l r low high 
		if(high < l or r < low) {
			return; 
		}

		// complete overlap 
		// l low high r 
		if(low>=l && high <= r) {
			seg[ind] += (high - low + 1) * val; 
			// if a leaf node, it will have childrens
			if(low != high) {
				lazy[2*ind+1] += val; 
				lazy[2*ind+2] += val; 
			}
			return; 
		}
		// last case has to be no overlap case
		int mid = (low + high) >> 1; 
		update(2*ind+1, low, mid, l, r, val);
		update(2*ind+2, mid+1, high, l, r, val); 
		seg[ind] = seg[2*ind+1] + seg[2*ind+2]; 
	}
public: 
	int query(int ind, int low, int high, int l, int r) {

		// update if any updates are remaining 
		// as the node will stay fresh and updated 
		if(lazy[ind] != 0) {
			seg[ind] += (high - low + 1) * lazy[ind]; 
			// propogate the lazy update downwards
			// for the remaining nodes to get updated 
			if(low != high) {
				lazy[2*ind+1] += lazy[ind]; 
				lazy[2*ind+2] += lazy[ind]; 
			}

			lazy[ind] = 0; 
		}

		// no overlap return 0; 
		if(high < l or r < low) {
			return 0; 
		}

		// complete overlap 
		if(low>=l && high <= r) return seg[ind]; 

		int mid = (low + high) >> 1; 
		int left = query(2*ind+1, low, mid, l, r);
		int right = query(2*ind+2, mid+1, high, l, r);
		return left + right; 
	}
};


class STMin {
	vector<int> seg, lazy; 
public: 
	STMin(int n) {
		seg.resize(4 * n); 
		lazy.resize(4 * n); 
	}
public: 
	void build(int ind, int low, int high, int arr[]) {
		if(low == high) {
			seg[ind] = arr[low];
			return; 
		}
		int mid = (low + high) >> 1; 
		build(2*ind+1, low, mid, arr); 
		build(2*ind+2, mid+1, high, arr); 
		seg[ind] = min(seg[2*ind+1], seg[2*ind+2]);
	}
public:
	void update(int ind, int low, int high, int l, int r, 
		int val) {
		// update the previous remaining updates 
		// and propogate downwards 
		if(lazy[ind] != 0) {
			seg[ind] += lazy[ind]; 
			// propogate the lazy update downwards
			// for the remaining nodes to get updated 
			if(low != high) {
				lazy[2*ind+1] += lazy[ind]; 
				lazy[2*ind+2] += lazy[ind]; 
			}

			lazy[ind] = 0; 
		}

		// no overlap 
		// we don't do anything and return 
		// low high l r or l r low high 
		if(high < l or r < low) {
			return; 
		}

		// complete overlap 
		// l low high r 
		if(low>=l && high <= r) {
			seg[ind] += val; 
			// if a leaf node, it will have childrens
			if(low != high) {
				lazy[2*ind+1] += val; 
				lazy[2*ind+2] += val; 
			}
			return; 
		}
		// last case has to be no overlap case
		int mid = (low + high) >> 1; 
		update(2*ind+1, low, mid, l, r, val);
		update(2*ind+2, mid+1, high, l, r, val); 
		seg[ind] = min(seg[2*ind+1], seg[2*ind+2]); 
	}
public: 
	int query(int ind, int low, int high, int l, int r) {

		// update if any updates are remaining 
		// as the node will stay fresh and updated 
		if(lazy[ind] != 0) {
			seg[ind] += lazy[ind]; 
			// propogate the lazy update downwards
			// for the remaining nodes to get updated 
			if(low != high) {
				lazy[2*ind+1] += lazy[ind]; 
				lazy[2*ind+2] += lazy[ind]; 
			}

			lazy[ind] = 0; 
		}

		// no overlap return 0; 
		if(high < l or r < low) {
			return INT_MAX; 
		}

		// complete overlap 
		if(low>=l && high <= r) return seg[ind]; 

		int mid = (low + high) >> 1; 
		int left = query(2*ind+1, low, mid, l, r);
		int right = query(2*ind+2, mid+1, high, l, r);
		return min(left,right); 
	}
};


class ST {
	vector<int> seg, lazy; 
public: 
	ST(int n) {
		seg.resize(4 * n); 
		lazy.resize(4 * n); 
	}
public: 
	void build(int ind, int low, int high, int arr[]) {
		if(low == high) {
			seg[ind] = arr[low];
			return; 
		}
		int mid = (low + high) >> 1; 
		build(2*ind+1, low, mid, arr); 
		build(2*ind+2, mid+1, high, arr); 
		seg[ind] = seg[2*ind+1] + seg[2*ind+2];
	}
public:
	void update(int ind, int low, int high, int l, int r, 
		int val) {
		// update the previous remaining updates 
		// and propogate downwards 
		if(lazy[ind] != 0) {
			seg[ind] = (high - low + 1) - seg[ind]; 
			// propogate the lazy update downwards
			// for the remaining nodes to get updated 
			if(low != high) {
				lazy[2*ind+1] = !lazy[2*ind + 1]; 
				lazy[2*ind+2] = !lazy[2*ind + 2]; 
			}

			lazy[ind] = 0; 
		}

		// no overlap 
		// we don't do anything and return 
		// low high l r or l r low high 
		if(high < l or r < low) {
			return; 
		}

		// complete overlap 
		// l low high r 
		if(low>=l && high <= r) {
			seg[ind] = (high - low + 1) - val; 
			// if a leaf node, it will have childrens
			if(low != high) {
				lazy[2*ind+1] = !lazy[2*ind + 1]; 
				lazy[2*ind+2] = !lazy[2*ind + 2]; 
			}
			return; 
		}
		// last case has to be no overlap case
		int mid = (low + high) >> 1; 
		update(2*ind+1, low, mid, l, r, val);
		update(2*ind+2, mid+1, high, l, r, val); 
		seg[ind] = seg[2*ind+1] + seg[2*ind+2]; 
	}
public: 
	int query(int ind, int low, int high, int l, int r) {

		// update if any updates are remaining 
		// as the node will stay fresh and updated 
		if(lazy[ind] != 0) {
			seg[ind] = (high - low + 1) - seg[ind]; 
			// propogate the lazy update downwards
			// for the remaining nodes to get updated 
			if(low != high) {
				lazy[2*ind+1] = !lazy[2*ind + 1]; 
				lazy[2*ind+2] = !lazy[2*ind + 2]; 
			}

			lazy[ind] = 0; 
		}

		// no overlap return 0; 
		if(high < l or r < low) {
			return 0; 
		}

		// complete overlap 
		if(low>=l && high <= r) return seg[ind]; 

		int mid = (low + high) >> 1; 
		int left = query(2*ind+1, low, mid, l, r);
		int right = query(2*ind+2, mid+1, high, l, r);
		return left + right; 
	}
};

int main() {
	#ifndef ONLINE_JUDGE
	freopen("input.txt", "r", stdin); 
	freopen("output.txt", "w", stdout); 
	#endif
	int n;
	cin >> n; 
	int arr[n];
	for(int i = 0;i<n;i++) cin >> arr[i]; 
	ST st(n+1); 
	st.build(0,0,n-1, arr); 

	int q;
	cin >> q; 
	while(q--) {
		int type;
		cin >> type; 
		if(type==1) {
			int l, r;
			cin >> l >> r;
			cout << st.query(0,0,n-1,l,r) << endl; 
		}
		else {
			int l, r, val;
			cin >> l >> r >> val; 
			st.update(0,0,n-1,l,r,val);
		}
	}
	return 0; 
}
